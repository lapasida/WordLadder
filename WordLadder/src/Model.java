
import java.io.BufferedReader;
import java.io.DataInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.List;
import java.util.NoSuchElementException;
import org.jgrapht.Graphs;
import org.jgrapht.alg.DijkstraShortestPath;
import org.jgrapht.graph.DefaultEdge;
import org.jgrapht.graph.SimpleGraph;
import org.jgrapht.traverse.DepthFirstIterator;

/*
 * This class is basically static class, which do all algorithm operations. 
 */
/**
 * @version 1.0
 * @author Stanislaw Jakub Klimaszewski
 */
public class Model {

    private final static String dataFile = "data.dat";

    /**
     * Loads only fixed length words from file.
     *
     * @param wordLength length of loading words
     * @return Hashtable only with keys (no values)
     */
    private static Hashtable<String, ArrayList<String>> loadWords(int wordLength) {
        ArrayList<String> words = new ArrayList<>();
        BufferedReader br;
        br = new BufferedReader(new InputStreamReader(new DataInputStream(Model.class.getResourceAsStream(dataFile))));
        String word;
        try {
            while ((word = br.readLine()) != null) {
                if (word.length() == wordLength) {
                    words.add(word);
                }
            }
        } catch (IOException ex) {
            System.err.println(ex);
        }
        Hashtable<String, ArrayList<String>> wordList = new Hashtable<>(words.size());
        for (String w : words) {
            wordList.put(w, new ArrayList<String>());
        }
        return wordList;
    }

    /**
     * Adds values to HashTable which has only keys.
     *
     * @param wordList HashTable with words loaded as keys, no value for each
     * key
     * @return HashTable with word as key and array list of smilar words as
     * value
     */
    private static Hashtable<String, ArrayList<String>> addValues(Hashtable<String, ArrayList<String>> wordList) {
        Enumeration e = wordList.keys();
        while (e.hasMoreElements()) {
            String key = (String) e.nextElement();
            wordList.put(key, findSimilarWords(key, wordList));
        }
        return wordList;
    }

    /**
     * Finds words from HashTable, which are similar to "word" variable.
     *
     * @param word
     * @param wordList HashTable with all words as key
     * @return ArrayList of similar words
     */
    private static ArrayList<String> findSimilarWords(String word, Hashtable<String, ArrayList<String>> wordList) {
        String possibleCharacters = "qwertyuiopasdfghjklzxcvbnm";
        char[] charList = possibleCharacters.toCharArray();
        ArrayList<String> similarWords = new ArrayList<>();
        char[] keyword = word.toCharArray();
        for (int i = 0; i < keyword.length; i++) {
            for (int j = 0; j < charList.length; j++) {
                keyword[i] = charList[j];
                String newWord = new String(keyword);
                if (wordList.containsKey(newWord) && !newWord.equals(word) && !similarWords.contains(newWord)) {
                    similarWords.add(newWord);
                }
            }
            keyword = word.toCharArray();
        }
        return similarWords;
    }

    /**
     * Generate graph from hashtable.
     *
     * @param words HashTable with word as key and ArrayList of similar words as
     * value
     * @return graph generated by JGrapht library
     */
    private static SimpleGraph generateGraph(Hashtable<String, ArrayList<String>> words) {
        SimpleGraph graph = new SimpleGraph<String, DefaultEdge>(DefaultEdge.class);
        Enumeration e = words.keys();
        while (e.hasMoreElements()) {
            String element = (String) e.nextElement();
            if (!graph.containsVertex(element)) {
                graph.addVertex(element);
            }
            ArrayList<String> wordList = words.get(element);
            for (String similarWord : wordList) {
                if (!graph.containsVertex(similarWord)) {
                    graph.addVertex(similarWord);
                }
                if (!graph.containsEdge(element, similarWord)) {
                    graph.addEdge(element, similarWord);
                }
            }
        }
        return graph;
    }

    /**
     * Generate word lader for word "word" with "steps" number of steps.
     *
     * @param word first word of ladder
     * @param steps number of steps
     * @return string with error or word ladder if successfull
     */
    public static String generateLadder(String word, String steps) {
        if (word.length() < 1 || steps.length() < 1) {
            return "Please fill in both textfields.";
        }
        int stepsNumber = 0;
        try {
            stepsNumber = Integer.parseInt(steps);
        } catch (NumberFormatException e) {
            return "Wrong number of steps.";
        }
        if (stepsNumber <= 0) {
            return "Wrong number of steps.";
        }
        Hashtable<String, ArrayList<String>> wordList = Model.loadWords(word.length());
        Hashtable<String, ArrayList<String>> hashTable = addValues(wordList);
        SimpleGraph graph = generateGraph(hashTable);
        DepthFirstIterator d = null;
        try {
            d = new DepthFirstIterator(graph, word);
        } catch (IllegalArgumentException e) {
            return "Cannot find word in database.";
        }
        String message = "";
        stepsNumber--;
        for (int i = 0; i <= stepsNumber; i++) {
            try {
                message += " -> " + d.next();
            } catch (NoSuchElementException e) {
                return "Cannot find so many steps.";
            }
            if (i % 10 == 0 && i != 0) {
                message += "\n";
            }
        }
        message = message.substring(4);
        return message;
    }

    /**
     * Discovers the shortest path from startWord to endWord.
     *
     * @param startWord first word of path
     * @param endWord last word of path
     * @return string with error or path if successfull
     */
    public static String discoverShortestPath(String startWord, String endWord) {
        if (startWord.length() < 1 || endWord.length() < 1) {
            return "Please fill in both textfields.";
        }
        if (startWord.length() != endWord.length()) {
            return "Both words have to be the same length.";
        }
        Hashtable<String, ArrayList<String>> wordList = loadWords(startWord.length());
        Hashtable<String, ArrayList<String>> table = addValues(wordList);
        SimpleGraph graph = generateGraph(table);
        DijkstraShortestPath path = null;
        try {
            path = new DijkstraShortestPath(graph, startWord, endWord);
        } catch (IllegalArgumentException e) {
            return "Cannot find words in database.";
        }
        if (path.getPath() == null) {
            return "Cannot find any path.";
        }
        List<String> vertexList = Graphs.getPathVertexList(path.getPath());
        String message = "";
        int i = 0;
        for (String vertex : vertexList) {
            message += " -> " + vertex;
            if (i % 10 == 0 && i != 0) {
                message += "\n";
            }
            i++;
        }
        message = message.substring(4);
        return message;
    }
}